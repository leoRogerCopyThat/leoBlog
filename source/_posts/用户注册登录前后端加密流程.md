---
title: 用户注册登录前后端加密流程
date: 2019-12-31 03:18:41
tags: code
categories: code
---

>> 截取自微信聊天，有空整理。

「乐予忘忧：一个密钥和密码结合然后MD5什么的」
- - - - - - - - - - - - - - -
长篇大论预警。
既然你node有讲到后端安全部分，现在有空和就你说说，我尽量说的通俗易懂些。

一般的内部项目或者不重要的项目，这这样加密已经够了，安全性不会太差，我也不知道你salt怎么生成的，应该没啥大问题。
我所里那个老爷系统，没上https，密码传输还是明文，照样安稳运行了这么多年。。不过如果有被中间人拦截登陆过也不得而知。

下面我说说我理解并在执行的在高保密度的项目中，相对规范加密流程是怎么做的：

首先，密码在前端部分就得加密，并不是说我们有了https信道加密就不用再做前端加密这件事了， 如果系统用户在一个大公司内网内访问，照样会面临内网证书伪造抓包。

这时的前端加密，当然不是想当然的套个md5就可以往服务器传，而是会使用RSA技术（类似我们密钥登录服务器，拿私钥解公钥），我们现在除了客户端（client），再加入两个新角色，server服务端，和openssl端，角色到位，我们来模拟下请求：

下面的描述我们用简写c-client，s-server，o-openssl：
c端在我们输入密码点登录之后，先向s端发出登录请求，
s端收到登录请求后，向o端发起申领密钥对请求，o端会生成并用base64返回a和b密钥对给s端，
s端收到密钥对后保留密钥b，把密钥a发送给c端，
然后c端拿收到的密钥a来加密用户输入的密码，然后把加密后的内容传给s端
-------至此，c端加密并发送给s端用户密码的阶段完成

下面进入s端解密步骤：
这时s端拿到的密码还不是明文的，肯定不能直接加密存储，因为下一次从o端领到的密钥对肯定不一样了，所以这时s端就要用刚才还留着的密钥b来解密c端发送过来的加密内容，解密完就是用户输的明文密码了。

然后s端开始对密码进行加密入库或者对比登录操作：
在加密前，先加入些pepper（胡椒），一般是固定内容，主要针对的场景是数据库暴露但是应用服务器安全，可以拖延字典攻击的时间，比如用户输入密码明文是pass123，我的pepper是leocool，那么第一步操作后，等待加密的内容就变成了pass123leocool

接着会使用Blowfish之类的模块进行哈希加密，使用造好的轮子有很多好处，比如我们这些没正经研究过密码学的半吊子，在解决密码问题上总会有小问题；用它还能让加salt（盐）和哈希加密及base64编码一步完成；还不用再单独拿个字段存salt等等。

我拿py的举例，比如：
我们先进行注册入库操作，执行
bcrypt.hashpw("pass123leocoo", bcrypt.gensalt())
bcrypt.hashpw接受两个参数，要加密的文本和salt，bcrypt.gensalt()将会自动生成一个salt。
执行完成后，结果就可以直接入库了，我们把输出结果打印下：
$2b$12$K947InrSXM6XvNoErbAcj.K5YQ/OSVvJ802MxSWNgXdrjmru8Grs2
结果分为4部分，$2b表明这是bcrypt格式的哈希，$12是cost值（成本）默认是12，第三部分是22位的salt，剩下的部分就是对"pass123leocoo"哈希后的base64编码的值。

那么如果这是一次登录，我们就需要拿数据库里的密文和加密数据进行比对，比如我们把刚才加密好的密文从数据库中取出，存入hash_pass变量，然后执行
pass = bcrypt.hashpw("pass123leocoo", hash_pass)
pass  == hash_pass
如果结果为true，即比对成功，我们可以看到，在执行对比加密时，刚才填bcrypt.gensalt()的地方换成了hash_pass，密文被当作solt传入了，是因为实际的比较中，它进行了版本的校验以及截断，重用了hash_pass中的salt值，所以最后生成的字符串是一样的。

至此，一个相对规范的加密解密流程就完成了。